<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>卫星轨道可视化系统</title>
  <link rel="stylesheet" href="https://unpkg.com/cesium@1.134/Build/Cesium/Widgets/widgets.css">
  <script src="https://unpkg.com/cesium@1.134/Build/Cesium/Cesium.js"></script>
  <script src="https://unpkg.com/satellite.js@5.0.0/dist/satellite.min.js"></script>
  <script src="./globeRotate.js"></script>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    #cesiumContainer {
      width: 100%;
      height: 100%;
    }
    .control-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 340px;
      max-height: 85vh;
      overflow-y: auto;
      background: rgba(30, 30, 30, 0.9);
      color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      font-family: 'Segoe UI', Arial, sans-serif;
      z-index: 1000;
      user-select: none;
    }
    .panel-header {
      padding: 12px 15px;
      border-bottom: 1px solid #444;
      cursor: move;
      background: rgba(40, 40, 40, 0.95);
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
    }
    .panel-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 500;
    }
    .panel-content {
      padding: 15px;
    }
    .global-controls {
      margin-bottom: 15px;
      padding: 0;
    }
    .control-item {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      width: 100%;
    }
    .toggle-switch {
      position: relative;
      width: 0px;
      height: 20px;
      margin: 0;
      appearance: none;
      cursor: pointer;
    }
    .toggle-switch + label {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
      background: #af4c4c;
      border: 0.5px solid rgba(117, 117, 117, 0.31);
      box-shadow: inset 0px 0px 2px 0px rgba(0,0,0,0.2);
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    .toggle-switch + label::before {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      box-shadow: inset 0.5px -1px 1px rgba(0, 0, 0, 0.35);
      background: #fff;
      transform: rotate(-20deg);
      left: 0;
      top: 0;
      border-radius: 50%;
      transition: transform 0.3s ease, left 0.3s ease;
    }
    .toggle-switch:checked + label {
      background: #4caf50;
    }
    .toggle-switch:checked + label::before {
      left: 20px;
      transform: rotate(20deg);
    }
    .switch-label-text {
      font-size: 12px;
      user-select: none;
      flex: 1;
    }
    /* 分组样式 */
    .constellation-group {
      border-top: 1px solid #444;
      padding-top: 15px;
      margin-top: 10px;
    }
    .constellation-header {
      margin: 10px 0 5px 0;
      padding: 6px 10px;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: rgba(60, 100, 180, 0.7);
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .level-1-group {
      margin-left: 15px;
      margin-bottom: 10px;
    }
    .level-1-header {
      margin: 8px 0 5px 0;
      padding: 5px 8px;
      font-size: 13px;
      font-weight: 500;
      color: #e0e0e0;
      background: rgba(80, 80, 120, 0.6);
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .level-2-group {
      margin-left: 30px;
      margin-bottom: 8px;
    }
    .level-2-header {
      margin: 6px 0 5px 0;
      padding: 4px 6px;
      font-size: 12px;
      font-weight: 500;
      color: #d0d0d0;
      background: rgba(80, 120, 80, 0.6);
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
      /* 三级分组（轨道面）- 修复类名和样式 */
  .level-3-group {
    margin-left: 45px; /* 三级分组缩进更大 */
    margin-bottom: 8px;
  }
  .level-3-header {
    margin: 6px 0 5px 0;
    padding: 4px 6px;
    font-size: 12px;
    font-weight: 500;
    color: #d0d0d0;
    background: rgba(120, 80, 80, 0.6); /* 三级分组颜色区分 */
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
    .group-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .group-collapsed .group-content {
      max-height: 0;
    }
    /* 确保嵌套的分组能正确应用样式 */
.level-1-group.group-collapsed > .group-content,
.level-2-group.group-collapsed > .group-content,
.level-3-group.group-collapsed > .group-content {
  max-height: 0;
}
    .group-expanded .group-content {
      max-height: 18000px;
    }
    .group-toggle {
      font-size: 10px;
      transition: transform 0.2s ease;
      margin-right: 5px;
    }
    .group-collapsed .group-toggle {
      transform: rotate(-90deg);
    }
    .group-expanded .group-toggle {
      transform: rotate(0);
    }
    .group-count {
      font-size: 11px;
      color: #ccc;
      background: rgba(50, 50, 50, 0.7);
      padding: 0 5px;
      border-radius: 8px;
    }
    .group-control {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .satellite-item {
      display: flex;
      align-items: center;
      padding: 5px 8px;
      margin: 0 0 4px 45px;
      border-radius: 3px;
      background: rgba(60, 60, 60, 0.5);
      cursor: pointer;
      transition: background 0.2s;
      font-size: 12px;
    }
    .satellite-item:hover {
      background: rgba(80, 80, 80, 0.7);
    }
    .satellite-item .visibility-indicator {
      width: 12px;
      height: 12px;
      border: 1px solid #aaa;
      border-radius: 2px;
      margin-right: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .satellite-item.visible .visibility-indicator {
      background-color: #4CAF50;
      border-color: #4CAF50;
    }
    .satellite-item.visible .visibility-indicator::after {
      content: "✓";
      font-size: 9px;
      color: white;
    }
    .satellite-item .name {
      flex: 1;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  
  <!-- 可拖动的控制面板 -->
  <div class="control-panel" id="draggablePanel">
    <div class="panel-header" id="dragHandle">
      <h3>卫星轨道控制</h3>
    </div>
    <div class="panel-content">
      <div class="global-controls">
        <div class="control-item">
          <input type="checkbox" id="toggleEarthRotate" class="toggle-switch" checked>
          <label for="toggleEarthRotate"></label>
          <span class="switch-label-text">地球自转</span>
        </div>
        <div class="control-item">
          <input type="checkbox" id="toggleAllOrbits" class="toggle-switch" checked>
          <label for="toggleAllOrbits"></label>
          <span class="switch-label-text">显示所有轨道</span>
        </div>
        <div class="control-item">
          <input type="checkbox" id="toggleAllLabels" class="toggle-switch" checked>
          <label for="toggleAllLabels"></label>
          <span class="switch-label-text">显示所有卫星名称</span>
        </div>
      </div>
      
      <!-- 卫星分组容器 -->
      <div class="satellite-groups" id="satelliteGroupsContainer">
        <!-- 分组内容将通过JS动态生成 -->
      </div>
    </div>
  </div>

  <script>
    // 初始化Cesium地图
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI0NmM1M2YxNC01YWNmLTQzOTAtYmY4MC02YWVlNTE2NDM3ZDYiLCJpZCI6MjYxOTQzLCJpYXQiOjE3MzM5OTU2MjB9.5cQ0mYBL1o0OQVIbB4J0BjTAxc-NoOxwHgwpYtJP-K8';
    window.CESIUM_BASE_URL = "https://unpkg.com/cesium@1.134/Build/Cesium/";
    const viewer = new Cesium.Viewer("cesiumContainer", {
      animation: true,
      timeline: true,
      sceneModePicker: true,
      baseLayerPicker: true,
    });

    // 全局状态管理
    const state = {
      constellations: {}, // 存储星座及内部分组结构
      satellites: [],          // 存储所有卫星数据
      globalShowOrbits: true,  // 全局轨道显示状态
      globalShowLabels: true   // 全局名称显示状态
    };

    // DOM元素引用
    const satelliteGroupsContainer = document.getElementById("satelliteGroupsContainer");
    const toggleAllOrbits = document.getElementById("toggleAllOrbits");
    const toggleAllLabels = document.getElementById("toggleAllLabels");
    const toggleEarthRotate = document.getElementById("toggleEarthRotate");
    const draggablePanel = document.getElementById("draggablePanel");
    const dragHandle = document.getElementById("dragHandle");

    /**
     * 实现控制面板拖动功能
     */
    function initDragFunctionality() {
      let isDragging = false;
      let offsetX, offsetY;

      // 鼠标按下时记录初始位置
      dragHandle.addEventListener('mousedown', (e) => {
        isDragging = true;
        const panelRect = draggablePanel.getBoundingClientRect();
        offsetX = e.clientX - panelRect.left;
        offsetY = e.clientY - panelRect.top;
        dragHandle.style.cursor = 'grabbing'; // 显示抓取光标
        document.body.style.userSelect = 'none'; // 防止拖动时选中文本
      });

      // 鼠标移动时更新面板位置
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        // 计算新位置（限制在窗口内）
        const newX = e.clientX - offsetX;
        const newY = e.clientY - offsetY;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const panelWidth = draggablePanel.offsetWidth;
        const panelHeight = draggablePanel.offsetHeight;

        // 限制面板在窗口可视范围内
        const constrainedX = Math.max(0, Math.min(newX, windowWidth - panelWidth));
        const constrainedY = Math.max(0, Math.min(newY, windowHeight - panelHeight));

        // 更新位置
        draggablePanel.style.left = `${constrainedX}px`;
        draggablePanel.style.top = `${constrainedY}px`;
        draggablePanel.style.right = 'auto'; // 取消右侧定位
        draggablePanel.style.bottom = 'auto'; // 取消底部定位
      });

      // 鼠标释放时结束拖动
      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          dragHandle.style.cursor = 'move'; // 恢复移动光标
          document.body.style.userSelect = ''; // 恢复文本选择
        }
      });

      // 鼠标离开窗口时结束拖动
      document.addEventListener('mouseleave', () => {
        if (isDragging) {
          isDragging = false;
          dragHandle.style.cursor = 'move';
          document.body.style.userSelect = '';
        }
      });
    }
    /**
     * 确定卫星所属分组
     * 根据卫星名称特征进行分组
     */
    function getConstellation(satelliteName) {
      const name = satelliteName.toLowerCase();
      if (name.includes('gps')) return 'GPS卫星';
      if (name.includes('noaa')) return 'NOAA卫星';
      if (name.includes('starlink')) return 'Starlink卫星';
      if (name.includes('iss') || name.includes('zarya')) return '国际空间站';
      if (name.includes('hst') || name.includes('hubble')) return '哈勃望远镜';
      if (name.includes('cosmos')) return '格洛纳斯卫星';
      if (name.includes('galileo')) return '伽利略卫星';
      if (name.includes('qzss')) return '日本准天顶卫星';
      if (name.includes('irnss')) return '印度导航卫星';
      if (name.includes('beidou-2') || name.includes('compass')) return '北斗2卫星';
      if (name.includes('beidou-3 ') || name.includes('compass')) return '北斗3卫星';
      return '其他卫星'; // 未匹配到的卫星归入其他组
    }

    /**
     * 从TLE数据解析轨道参数
     */
    function getOrbitParameters(satrec) {
      // 轨道周期（分钟）
      //const period = satrec.no ? (1440 / (satrec.no * 24 / 1.02759)) : 0;
      const period = 2*Math.PI/satrec.no;
      
      // 轨道倾角（度）
      const inclination = satrec.inclo / Math.PI * 180;
      
      // 升交点赤经（度）
      const raan = satrec.nodeo / Math.PI * 180;
      
      return {
        period,
        inclination,
        raan,
        // 标准化RAAN（0-360度）
        normalizedRaan: ((raan % 360) + 360) % 360
      };
    }

    /**
     * 第二步：星座内一级分组（轨道类型）
     */
    function getConstellationLevel1(constellationId, params) {
      // 地球同步轨道周期约1436分钟（23小时56分）
      const isGeosynchronous = Math.abs(params.period - 1436) < 60;
      //console.log(params.period,params.period/60);
      if (isGeosynchronous) {
        if (params.inclination < 5) {
          return { id: 'geo', name: '地球静止轨道 (GEO)' };
        } else {
          return { id: 'igso', name: '倾斜地球同步轨道 (IGSO)' };
        }
      } else if (params.period < 100) { // <20小时
        return { id: 'leo', name: '低轨道 (LEO)' };
      } else if (params.period < 1200){
        return { id: 'meo', name: '中轨道 (MEO)'};
      } else{
        return { id: 'other', name: '其他轨道' };
      }
    }

    /**
     * 第三步：星座内二级分组（仅中低轨道需要）
     * 按轨道倾角（相差<1度归为一类）
     */
    function getConstellationLevel2(constellationId, level1Id, params, existingGroups) {
      // GEO/IGSO不细分二级分组
      if (level1Id === 'geo' || level1Id === 'igso') {
        return { id: 'none', name: '无需细分' };
      }
      //console.log("func getL2:",existingGroups);
      
      // 中低轨按倾角聚类（相差<1度）
      const targetIncl = params.inclination;
      for (const groupId in existingGroups) {
        const incl = parseFloat(groupId.replace('incl_', ''));
        if (Math.abs(incl - targetIncl) < 5) {
          return {
            id: groupId,
            name: `轨道倾角: ${incl.toFixed(0)}°`
          };
        }
      }
      
      // 创建新分组
      const inclStr = targetIncl.toFixed(0);
      return {
        id: `incl_${inclStr}`,
        name: `轨道倾角: ${inclStr}°`
      };
    }

    /**
     * 第四步：星座内三级分组（仅中低轨道需要）
     * 按升交点赤经RAAN（相差<1度归为一个轨道面）
     */
    function getConstellationLevel3(constellationId, level1Id, level2Id, params, existingGroups) {
      // GEO/IGSO不细分三级分组
      if (level1Id === 'geo' || level1Id === 'igso') {
        return { id: 'none', name: '无需细分' };
      }
      
      // 中低轨按RAAN聚类（相差<1度）
      const targetRaan = params.normalizedRaan;
      for (const groupId in existingGroups) {
        const raan = parseFloat(groupId.replace('raan_', ''));
        if (Math.abs(raan - targetRaan) < 10) {
          return {
            id: groupId,
            name: `轨道面 (RAAN: ${raan.toFixed(0)}°)`,
            raanValue: raan // 存储RAAN值用于排序
          };
        }
      }
      
      // 创建新分组
      const raanStr = targetRaan.toFixed(0);
      const raanValue = parseFloat(raanStr);
      return {
        id: `raan_${raanStr}`,
        name: `轨道面 (RAAN: ${raanStr}°)`,
        raanValue: raanValue // 存储RAAN值用于排序
      };
    }

    /**
     * 创建完整分组结构：星座 → 轨道类型 → 倾角 → 轨道面
     */
    function createGroupStructure(satellite) {
      const { constellation, level1, level2, level3, params } = satellite;
      //console.log(constellation,level1,level2);
      
      // 1. 初始化星座分组
      if (!state.constellations[constellation]) {
        const constelElement = document.createElement('div');
        constelElement.className = 'constellation-group group-expanded';
        const switchId = `constel_${constellation}`;
        
        constelElement.innerHTML = `
          <div class="constellation-header">
            <span class="group-toggle">▸</span>
            <span>${constellation}</span>
            <span class="group-count">0</span>
            <div class="group-control">
              <input type="checkbox" id="${switchId}" class="toggle-switch" checked>
              <label for="${switchId}"></label>
            </div>
          </div>
          <div class="group-content"></div>
        `;
        
        // 星座折叠/展开
        const header = constelElement.querySelector('.constellation-header');
        header.addEventListener('click', (e) => {
          if (!e.target.closest('.group-control')) {
            constelElement.classList.toggle('group-expanded');
            constelElement.classList.toggle('group-collapsed');
          }
        });
        
        // 星座显隐控制
        const toggle = constelElement.querySelector('.toggle-switch');
        toggle.addEventListener('change', (e) => {
          toggleConstellationSatellites(constellation, e.target.checked);
        });
        
        state.constellations[constellation] = {
          name: constellation,
          element: constelElement,
          countElement: constelElement.querySelector('.group-count'),
          toggleElement: toggle,
          level1Groups: {}
        };
        
        satelliteGroupsContainer.appendChild(constelElement);
      }
      
      const constellationGroup = state.constellations[constellation];
      
      // 2. 初始化星座内一级分组（轨道类型）
      if (!constellationGroup.level1Groups[level1.id]) {
        const level1Element = document.createElement('div');
        level1Element.className = 'level-1-group group-expanded';
        const switchId = `level1_${constellation}_${level1.id}`;
        
        level1Element.innerHTML = `
          <div class="level-1-header">
            <span class="group-toggle">▸</span>
            <span>${level1.name}</span>
            <span class="group-count">0</span>
            <div class="group-control">
              <input type="checkbox" id="${switchId}" class="toggle-switch" checked>
              <label for="${switchId}"></label>
            </div>
          </div>
          <div class="group-content"></div>
        `;
        
        // 一级分组折叠/展开
        const header = level1Element.querySelector('.level-1-header');
        header.addEventListener('click', (e) => {
          if (!e.target.closest('.group-control')) {
            level1Element.classList.toggle('group-expanded');
            level1Element.classList.toggle('group-collapsed');
          }
        });
        
        // 一级分组显隐控制
        const toggle = level1Element.querySelector('.toggle-switch');
        toggle.addEventListener('change', (e) => {
          toggleLevel1Satellites(constellation, level1.id, e.target.checked);
        });
        
        constellationGroup.level1Groups[level1.id] = {
          name: level1.name,
          id:level1.id,
          element: level1Element,
          countElement: level1Element.querySelector('.group-count'),
          toggleElement: toggle,
          level2Groups: {}
        };
        
        constellationGroup.element.querySelector('.group-content').appendChild(level1Element);
      }
      
      const level1Group = constellationGroup.level1Groups[level1.id];
      
      // GEO/IGSO不创建二级和三级分组
      if (level1.id === 'geo' || level1.id === 'igso') {
        // 将卫星直接添加到一级分组
        if (!level1Group.satellites) level1Group.satellites = [];
        level1Group.satellites.push(satellite.name);
        updateGroupCounts();
        return level1Group.element.querySelector('.group-content');
      }
      
      // 3. 初始化星座内二级分组（倾角）
      if (!level1Group.level2Groups[level2.id]) {
        const level2Element = document.createElement('div');
        level2Element.className = 'level-2-group group-expanded';
        const switchId = `level2_${constellation}_${level1.id}_${level2.id}`;
        
        level2Element.innerHTML = `
          <div class="level-2-header">
            <span class="group-toggle">▸</span>
            <span>${level2.name}</span>
            <span class="group-count">0</span>
            <div class="group-control">
              <input type="checkbox" id="${switchId}" class="toggle-switch" checked>
              <label for="${switchId}"></label>
            </div>
          </div>
          <div class="group-content"></div>
        `;
        
        // 二级分组折叠/展开
        const header = level2Element.querySelector('.level-2-header');
        header.addEventListener('click', (e) => {
          if (!e.target.closest('.group-control')) {
            level2Element.classList.toggle('group-expanded');
            level2Element.classList.toggle('group-collapsed');
          }
        });
        
        // 二级分组显隐控制
        const toggle = level2Element.querySelector('.toggle-switch');
        toggle.addEventListener('change', (e) => {
          toggleLevel2Satellites(constellation, level1.id, level2.id, e.target.checked);
        });
        
        level1Group.level2Groups[level2.id] = {
          name: level2.name,
          id: level2.id,
          element: level2Element,
          countElement: level2Element.querySelector('.group-count'),
          toggleElement: toggle,
          level3Groups: {}
        };
        
        level1Group.element.querySelector('.group-content').appendChild(level2Element);
      }
      
      const level2Group = level1Group.level2Groups[level2.id];
      
      // 4. 初始化星座内三级分组（轨道面）
      if (!level2Group.level3Groups[level3.id]) {
        const level3Element = document.createElement('div');
        level3Element.className = 'level-3-group group-expanded';
        const switchId = `level3_${constellation}_${level1.id}_${level2.id}_${level3.id}`;
        
        level3Element.innerHTML = `
          <div class="level-3-header">
            <span class="group-toggle">▸</span>
            <span>${level3.name}</span>
            <span class="group-count">0</span>
            <div class="group-control">
              <input type="checkbox" id="${switchId}" class="toggle-switch" checked>
              <label for="${switchId}"></label>
            </div>
          </div>
          <div class="group-content"></div>
        `;
        
        // 三级分组折叠/展开
        const header = level3Element.querySelector('.level-3-header');
        header.addEventListener('click', (e) => {
          if (!e.target.closest('.group-control')) {
            level3Element.classList.toggle('group-expanded');
            level3Element.classList.toggle('group-collapsed');
          }
        });
        
        // 三级分组显隐控制
        const toggle = level3Element.querySelector('.toggle-switch');
        toggle.addEventListener('change', (e) => {
          toggleLevel3Satellites(constellation, level1.id, level2.id, level3.id, e.target.checked);
        });
        
        level2Group.level3Groups[level3.id] = {
          name: level3.name,
          id: level3.id,
          element: level3Element,
          countElement: level3Element.querySelector('.group-count'),
          toggleElement: toggle,
          satellites: [],
          raanValue: level3.raanValue // 关键：保存RAAN值
        };
        
        level2Group.element.querySelector('.group-content').appendChild(level3Element);
      }
      
      // 将卫星添加到三级分组
      const level3Group = level2Group.level3Groups[level3.id];
      level3Group.satellites.push(satellite.name);
      
      // 更新各级计数
      updateGroupCounts();
      
      return level3Group.element.querySelector('.group-content');
    }
    /**
     * 新增：按RAAN值排序轨道面分组
     */
    function sortOrbitPlanes() {
      // 遍历所有星座
      Object.values(state.constellations).forEach(constellation => {
        // 遍历星座内的一级分组（仅处理中低轨道）
        Object.values(constellation.level1Groups).forEach(level1Group => {
          if (level1Group.id === 'geo' || level1Group.id === 'igso') return; // 只排序中低轨的轨道面
          
          // 遍历二级分组（倾角）
          Object.values(level1Group.level2Groups).forEach(level2Group => {
            const level3Container = level2Group.element.querySelector('.group-content');
            if (!level3Container) return;
            
            // 1. 获取当前二级分组下的所有轨道面分组，并按RAAN值排序
            const sortedLevel3Groups = Object.values(level2Group.level3Groups)
              .sort((a, b) => a.raanValue - b.raanValue); // 按RAAN从小到大排序
            
            // 2. 清空容器并按排序后的顺序重新添加轨道面
            level3Container.innerHTML = '';
            sortedLevel3Groups.forEach(level3Group => {
              level3Container.appendChild(level3Group.element);
            });
          });
        });
      });
    }
    /**
     * 更新所有分组的计数
     */
    function updateGroupCounts() {
      // 遍历所有星座
      Object.values(state.constellations).forEach(constellation => {
        let constelCount = 0;
        
        // 遍历星座内一级分组
        Object.values(constellation.level1Groups).forEach(level1 => {
          let level1Count = 0;
          // GEO/IGSO直接统计一级分组内的卫星
          if (level1.id === 'geo' || level1.id === 'igso') {
            level1Count = level1.satellites?.length || 0;
            level1.countElement.textContent = level1Count;
            constelCount += level1Count;
            return;
          }
          
          // 中低轨统计二级分组
          Object.values(level1.level2Groups).forEach(level2 => {
            let level2Count = 0;
            
            // 统计三级分组
            Object.values(level2.level3Groups).forEach(level3 => {
              const count = level3.satellites.length;
              level3.countElement.textContent = count;
              level2Count += count;
            });
            
            level2.countElement.textContent = level2Count;
            level1Count += level2Count;
          });
          
          level1.countElement.textContent = level1Count;
          constelCount += level1Count;
        });
        
        constellation.countElement.textContent = constelCount;
      });
    }

    /**
     * 切换整个星座的卫星显隐
     */
    function toggleConstellationSatellites(constellationId, isVisible) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      // 遍历星座内所有一级分组
      Object.values(constellation.level1Groups).forEach(level1 => {
        // GEO/IGSO直接处理一级分组内卫星
        if (level1.id === 'geo' || level1.id === 'igso') {
          level1.satellites?.forEach(satName => {
            updateSatelliteVisibilityByName(satName, isVisible);
          });
          level1.toggleElement.checked = isVisible;
          return;
        }
        
        // 处理中低轨的二级和三级分组
        Object.values(level1.level2Groups).forEach(level2 => {
          Object.values(level2.level3Groups).forEach(level3 => {
            level3.satellites.forEach(satName => {
              updateSatelliteVisibilityByName(satName, isVisible);
            });
            level3.toggleElement.checked = isVisible;
          });
          level2.toggleElement.checked = isVisible;
        });
        level1.toggleElement.checked = isVisible;
      });
    }

    /**
     * 切换星座内一级分组的卫星显隐
     */
    function toggleLevel1Satellites(constellationId, level1Id, isVisible) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      // GEO/IGSO直接处理一级分组内卫星
      if (level1.id === 'geo' || level1.id === 'igso') {
        level1.satellites?.forEach(satName => {
          updateSatelliteVisibilityByName(satName, isVisible);
        });
        level1.toggleElement.checked = isVisible;
        syncConstellationToggleState(constellationId);
        return;
      }
      
      // 处理中低轨的二级和三级分组
      Object.values(level1.level2Groups).forEach(level2 => {
        Object.values(level2.level3Groups).forEach(level3 => {
          level3.satellites.forEach(satName => {
            updateSatelliteVisibilityByName(satName, isVisible);
          });
          level3.toggleElement.checked = isVisible;
        });
        level2.toggleElement.checked = isVisible;
      });
      
      syncConstellationToggleState(constellationId);
    }

    /**
     * 切换星座内二级分组的卫星显隐
     */
    function toggleLevel2Satellites(constellationId, level1Id, level2Id, isVisible) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      
      const level2 = level1.level2Groups[level2Id];
      if (!level2) return;
      
      // 处理三级分组
      Object.values(level2.level3Groups).forEach(level3 => {
        level3.satellites.forEach(satName => {
          updateSatelliteVisibilityByName(satName, isVisible);
        });
        level3.toggleElement.checked = isVisible;
      });
      
      syncLevel1ToggleState(constellationId, level1Id);
      syncConstellationToggleState(constellationId);
    }

    /**
     * 切换星座内三级分组的卫星显隐
     */
    function toggleLevel3Satellites(constellationId, level1Id, level2Id, level3Id, isVisible) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      
      const level2 = level1.level2Groups[level2Id];
      if (!level2) return;
      
      const level3 = level2.level3Groups[level3Id];
      if (!level3) return;
      
      // 更新卫星状态
      level3.satellites.forEach(satName => {
        updateSatelliteVisibilityByName(satName, isVisible);
      });
      level3.toggleElement.checked = isVisible;
      
      syncLevel2ToggleState(constellationId, level1Id, level2Id);
      syncLevel1ToggleState(constellationId, level1Id);
      syncConstellationToggleState(constellationId);
    }

    /**
     * 按名称更新卫星可见性
     */
    function updateSatelliteVisibilityByName(satName, isVisible) {
      const satellite = state.satellites.find(s => s.name === satName);
      if (satellite) {
        satellite.isVisible = isVisible;
        satellite.listItem.classList.toggle('visible', isVisible);
        updateSatelliteVisibility(satellite);
      }
    }

    /**
     * 同步二级分组开关状态
     */
    function syncLevel2ToggleState(constellationId, level1Id, level2Id) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      
      const level2 = level1.level2Groups[level2Id];
      if (!level2) return;
      
      const level3Groups = Object.values(level2.level3Groups);
      const allChecked = level3Groups.every(g => g.toggleElement.checked);
      const allUnchecked = level3Groups.every(g => !g.toggleElement.checked);
      
      if (allChecked) level2.toggleElement.checked = true;
      else if (allUnchecked) level2.toggleElement.checked = false;
    }

    /**
     * 同步一级分组开关状态
     */
    function syncLevel1ToggleState(constellationId, level1Id) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      
      // GEO/IGSO处理方式
      if (level1.id === 'geo' || level1.id === 'igso') {
        const allVisible = level1.satellites?.every(satName => {
          const sat = state.satellites.find(s => s.name === satName);
          return sat?.isVisible;
        }) || false;
        
        const allHidden = level1.satellites?.every(satName => {
          const sat = state.satellites.find(s => s.name === satName);
          return !sat?.isVisible;
        }) || false;
        
        if (allVisible) level1.toggleElement.checked = true;
        else if (allHidden) level1.toggleElement.checked = false;
        return;
      }
      
      // 中低轨处理方式
      const level2Groups = Object.values(level1.level2Groups);
      const allChecked = level2Groups.every(g => g.toggleElement.checked);
      const allUnchecked = level2Groups.every(g => !g.toggleElement.checked);
      
      if (allChecked) level1.toggleElement.checked = true;
      else if (allUnchecked) level1.toggleElement.checked = false;
    }

    /**
     * 同步星座开关状态
     */
    function syncConstellationToggleState(constellationId) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1Groups = Object.values(constellation.level1Groups);
      const allChecked = level1Groups.every(g => g.toggleElement.checked);
      const allUnchecked = level1Groups.every(g => !g.toggleElement.checked);
      
      if (allChecked) constellation.toggleElement.checked = true;
      else if (allUnchecked) constellation.toggleElement.checked = false;
    }

    /**
     * 1. 加载并解析TLE数据
     */
    async function loadTLEFile(filePath) {
      try {
        const response = await fetch(filePath);
        const text = await response.text();
        return parseTLE(text); // 解析TLE文本
      } catch (error) {
        console.error("读取TLE文件失败：", error);
        return [];
      }
    }

    // 2. 解析TLE文本
    function parseTLE(text) {
      const tleList = [];
      const lines = text.split(/[\n,]+/).map(line => line.trim()).filter(line => line);
      for (let i = 0; i + 2 < lines.length; i += 3) {
        const name = lines[i];
        const line1 = lines[i + 1];
        const line2 = lines[i + 2];
        if (line1.startsWith('1 ') && line2.startsWith('2 ')) {
          tleList.push({ name, line1, line2 });
        }
      }
      return tleList;
    }

    /**
     * 2. 预计算卫星轨道（ECI坐标系）
     * @param {Object} satrec - 卫星轨道参数
     * @param {number} points - 轨道点数量
     * @param {number} period - 轨道周期（毫秒）
     * @returns {Cesium.Cartesian3[]} 轨道点数组
     */
    function precomputeOrbit(satrec,time) {
      //console.log(satrec.ecco);
      const points = satrec.ecco>0.1?500:5;
      const period =  2*Math.PI/satrec.no*60*1000;
      const orbitPoints = [];
      const startTime = Cesium.JulianDate.toDate(time);;
      
      for (let i = 0; i < points; i++) {
        const time = new Date(startTime.getTime() + (i / points) * period);
        const position = satellite.propagate(satrec, time).position;
        
        const isNumber = (val) => typeof val === 'number' && !isNaN(val) && isFinite(val);
        if(!(isNumber(position.x)&&isNumber(position.y)&&isNumber(position.z))){
          console.log(satrec.satnum,"propagate error");
          return orbitPoints;
        }
        
        // 转换为米并存储
        orbitPoints.push(Cesium.Cartesian3.fromElements(
          position.x * 1000,
          position.y * 1000,
          position.z * 1000
        ));
      }
      orbitPoints.push(orbitPoints[0]);
      return orbitPoints;
    }
   function computeECFOrbit(satrec,time){
      const startTime = Cesium.JulianDate.toDate(time);
      const points = 300;
      const period =  2*Math.PI/satrec.no*60*1000;
      const orbitPoints = [];
      for (let i = 0; i < points; i++) {
        const time = new Date(startTime.getTime() + (i / points) * period);
        const eciPosition = satellite.propagate(satrec, time).position;
        const isNumber = (val) => typeof val === 'number' && !isNaN(val) && isFinite(val);
        if(!(isNumber(eciPosition.x)&&isNumber(eciPosition.y)&&isNumber(eciPosition.z))){
          console.log(satrec.satnum,"propagate error");
          return orbitPoints;
        }

        const gmst = satellite.gstime(time); // 计算格林尼治恒星时
        const position = satellite.eciToEcf(eciPosition, gmst);
      
        // 转换为米并存储
        orbitPoints.push(Cesium.Cartesian3.fromElements(
          position.x * 1000,
          position.y * 1000,
          position.z * 1000
        ));
      }
      
      return orbitPoints;
    }
    /**
     * 3. 创建卫星实体和轨道
     * @param {Object} tle - TLE数据
     */
    function createSatellite(tle) {
      try {
        // 解析TLE数据
        const satrec = satellite.twoline2satrec(tle.line1, tle.line2);
        if (satrec.error) throw new Error(satrec.error);

        // 1. 确定星座
        const constellation = getConstellation(tle.name);
        
        // 2. 获取轨道参数
        const params = getOrbitParameters(satrec);
        
        // 3. 确定星座内一级分组（轨道类型）
        const level1 = getConstellationLevel1(constellation, params);

        // 4. 确定星座内二级分组（倾角）
        const existingLevel2Groups = state.constellations[constellation]?.level1Groups[level1.id]?.level2Groups || {};
        const level2 = getConstellationLevel2(constellation, level1.id, params, existingLevel2Groups);
        
        // 5. 确定星座内三级分组（轨道面）
        const existingLevel3Groups = state.constellations[constellation]?.level1Groups[level1.id]?.level2Groups[level2.id]?.level3Groups || {};
        const level3 = getConstellationLevel3(constellation, level1.id, level2.id, params, existingLevel3Groups);

        // 预计算轨道
        //const eciOrbit = precomputeOrbit(satrec,viewer.clock.currentTime);
        
        // 生成随机颜色（区分不同卫星）
        const color = Cesium.Color.fromRandom({
          minimumRed: 0.5,
          minimumGreen: 0.5,
          minimumBlue: 0.5,
          alpha: 0.8
        });

        /*// 创建轨道Primitive
        const orbitGeometry = new Cesium.PolylineGeometry({
          positions: eciOrbit,
          width: 1,
          vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT
        });
        const orbitInstance = new Cesium.GeometryInstance({
          geometry: orbitGeometry,
          id: tle.name
        });
        const orbitAppearance = new Cesium.PolylineMaterialAppearance({
          material: Cesium.Material.fromType(Cesium.Material.ColorType, { color })
        });
        const orbitPrimitive = new Cesium.Primitive({
          geometryInstances: orbitInstance,
          appearance: orbitAppearance,
          modelMatrix: Cesium.Matrix4.IDENTITY,
          show: true
        });
        viewer.scene.primitives.add(orbitPrimitive);*/

        // 创建卫星点实体
        const satelliteEntity = viewer.entities.add({
          name: tle.name,
          position: Cesium.Cartesian3.ZERO,
          point: {
            pixelSize: 6,
            color: color,
            outlineWidth: 1,
            outlineColor: Cesium.Color.BLACK
          },
          label: {
            text: tle.name,
            font: "12px sans-serif",
            pixelOffset: new Cesium.Cartesian2(0, 15),
            show: true
          },
          show: true
        });

        // 创建列表项
        const listItem = document.createElement("div");
        listItem.className = "satellite-item visible";
        listItem.innerHTML = `
          <span class="visibility-indicator"></span>
          <span class="name">${tle.name} (周期: ${params.period.toFixed(1)}分钟)</span>
        `;
        listItem.dataset.name = tle.name;

        // 卫星项点击事件
        listItem.addEventListener("click", (e) => {
          e.stopPropagation();
          const isVisible = !listItem.classList.contains("visible");
          listItem.classList.toggle("visible", isVisible);
          
          const satellite = state.satellites.find(s => s.name === tle.name);
          if (satellite) {
            satellite.isVisible = isVisible;
            updateSatelliteVisibility(satellite);
            
            // 同步各级开关状态
            if (level1.id === 'geo' || level1.id === 'igso') {
              syncLevel1ToggleState(constellation, level1.id);
            } else {
              syncLevel3ToggleState(constellation, level1.id, level2.id, level3.id);
              syncLevel2ToggleState(constellation, level1.id, level2.id);
              syncLevel1ToggleState(constellation, level1.id);
            }
            syncConstellationToggleState(constellation);
          }
        });

        // 将卫星添加到分组结构
        const parentContainer = createGroupStructure({
          name: tle.name,
          constellation,
          level1,
          level2,
          level3,
          params
        });
        parentContainer.appendChild(listItem);

        return {
          name: tle.name,
          constellation,
          level1,
          level2,
          level3,
          params,
          satrec,
          eciOrbit:null,
          orbitPrimitive:null,
          satelliteEntity,
          listItem,
          isVisible: true,
          color
        };
      } catch (error) {
        console.error(`创建卫星${tle.name}失败:`, error);
        return null;
      }
    }
/**
 * 为单颗卫星创建轨道（原轨道创建逻辑抽离）
 */
function createSatelliteOrbit(sat,time,rotationMatrix) {
  try {
    // 预计算轨道点（这一步最耗时，放在分批处理中）
    const eciOrbit = precomputeOrbit(sat.satrec,time);// 点数可减少至200
    sat.eciOrbit = eciOrbit;
    //console.log(sat.name,time,eciOrbit.length);

    // 创建轨道几何和图元
    const orbitGeometry = new Cesium.PolylineGeometry({
      positions: eciOrbit,
      width: 1,
      vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT
    });
    const orbitInstance = new Cesium.GeometryInstance({
      geometry: orbitGeometry,
      id: sat.name
    });
    const orbitAppearance = new Cesium.PolylineMaterialAppearance({
      material: Cesium.Material.fromType(Cesium.Material.ColorType, { color: sat.color })
    });
    const orbitPrimitive = new Cesium.Primitive({
      geometryInstances: orbitInstance,
      appearance: orbitAppearance,
      modelMatrix: rotationMatrix,
      show: sat.isVisible && state.globalShowOrbits
    });

    // 添加到场景并更新卫星对象
    viewer.scene.primitives.add(orbitPrimitive);
    sat.orbitPrimitive = orbitPrimitive;
  } catch (error) {
    console.error(`创建${sat.name}轨道失败:`, error);
  }
}
/**
 * 分批次创建卫星轨道
 * @param {Array} satellites - 所有卫星对象数组
 * @param {number} batchSize - 每批创建的轨道数量（建议20~50）
 * @param {number} delay - 批次间隔时间（毫秒，建议100~300）
 */
function createOrbitsInBatches(satellites, batchSize = 30, delay = 200) {
  let index = 0; // 当前处理的卫星索引
  const time =viewer.clock.currentTime;
  const date = Cesium.JulianDate.toDate(time);
  const gmst = satellite.gstime(date); // 计算格林尼治恒星时
  const rotationMatrix = Cesium.Matrix4.fromRotation(
    new Cesium.Matrix3.fromRotationZ(-gmst) // 地球自转矩阵
  ); 
  // 处理单批轨道创建
  function processBatch() {
    if (index >= satellites.length) {
      console.log("所有轨道创建完成");
      return; // 全部处理完，退出
    }
    console.log("batch: ",index," length: ",satellites.length);
    // 计算当前批次的卫星范围
    const end = Math.min(index + batchSize, satellites.length);
    for (let i = index; i < end; i++) {
      const sat = satellites[i];
      if (!sat.orbitPrimitive) { // 跳过已创建轨道的卫星
        createSatelliteOrbit(sat,time,rotationMatrix); // 为单颗卫星创建轨道
      }
    }

    index = end; // 更新索引
    // 延迟处理下一批，避免阻塞主线程
    setTimeout(processBatch, delay);
  }

  // 启动第一批处理
  processBatch();
}
    function updateSatelliteOrbit(sat,time,rotationMatrix){
        var orbitpoint;
        var modelmatrix;
        if(viewer.scene.mode === Cesium.SceneMode.SCENE3D){
          orbitpoint = precomputeOrbit(sat.satrec,time);
          modelmatrix = rotationMatrix;
        }else{
          orbitpoint = computeECFOrbit(sat.satrec,time);
          modelmatrix = Cesium.Matrix4.IDENTITY;
        }
        
        // 3. 创建新的轨道几何（使用新坐标点）
  const newOrbitGeometry = new Cesium.PolylineGeometry({
    positions: orbitpoint,  // 新坐标点数组
    width: 1,                   // 线宽（保持不变或修改）
    vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT
  });

  // 4. 创建新的几何实例
  const newOrbitInstance = new Cesium.GeometryInstance({
    geometry: newOrbitGeometry,
    id: sat.name  // 保持与卫星关联的ID
  });

  // 5. 复用原有的外观样式（或创建新样式）
  const newOrbitAppearance = sat.orbitPrimitive.appearance;  // 复用颜色等样式

  // 6. 创建新的轨道图元
  const newOrbitPrimitive = new Cesium.Primitive({
    geometryInstances: newOrbitInstance,
    appearance: newOrbitAppearance,
    modelMatrix: modelmatrix, // 保持坐标系转换矩阵
    show: sat.orbitPrimitive.show                // 保持显隐状态
  });

  // 7. 将新图元添加到场景，并更新卫星对象的引用
  viewer.scene.primitives.remove(sat.orbitPrimitive);
  viewer.scene.primitives.add(newOrbitPrimitive);
  sat.orbitPrimitive = newOrbitPrimitive; 
      
    }
/**
 * 分批次更新卫星轨道
 * @param {Array} satellites - 所有卫星对象数组
 * @param {number} batchSize - 每批创建的轨道数量（建议20~50）
 * @param {number} delay - 批次间隔时间（毫秒，建议100~300）
 */
function updateOrbitsInBatches(satellites, batchSize = 30, delay = 200) {
  let index = 0; // 当前处理的卫星索引
  const time =viewer.clock.currentTime;
  const date = Cesium.JulianDate.toDate(time);
  const gmst = satellite.gstime(date); // 计算格林尼治恒星时
  const rotationMatrix = Cesium.Matrix4.fromRotation(
    new Cesium.Matrix3.fromRotationZ(-gmst) // 地球自转矩阵
  ); 
  // 处理单批轨道创建
  function processBatch() {
    if (index >= satellites.length) {
      console.log("所有轨道更新完成");
      return; // 全部处理完，退出
    }
    console.log("batch: ",index," length: ",satellites.length);
    // 计算当前批次的卫星范围
    const end = Math.min(index + batchSize, satellites.length);
    for (let i = index; i < end; i++) {
      const sat = satellites[i];
      updateSatelliteOrbit(sat,time,rotationMatrix); // 为单颗卫星创建轨道
    }

    index = end; // 更新索引
    // 延迟处理下一批，避免阻塞主线程
    setTimeout(processBatch, delay);
  }

  // 启动第一批处理
  processBatch();
}    /**
     * 同步三级分组开关状态
     */
    function syncLevel3ToggleState(constellationId, level1Id, level2Id, level3Id) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      
      const level2 = level1.level2Groups[level2Id];
      if (!level2) return;
      
      const level3 = level2.level3Groups[level3Id];
      if (!level3) return;
      
      // 检查该组所有卫星状态
      const allVisible = level3.satellites.every(satName => {
        const sat = state.satellites.find(s => s.name === satName);
        return sat?.isVisible;
      });
      
      const allHidden = level3.satellites.every(satName => {
        const sat = state.satellites.find(s => s.name === satName);
        return !sat?.isVisible;
      });
      
      if (allVisible) level3.toggleElement.checked = true;
      else if (allHidden) level3.toggleElement.checked = false;
    }

    /**
     * 4. 更新卫星可见性（结合全局开关和自身状态）
     * @param {Object} sat - 卫星对象
     */
    function updateSatelliteVisibility(sat) {
      const { isVisible } = sat;
      // 轨道可见性 = 自身可见 && 全局轨道开启
      if(sat.orbitPrimitive!==null){
        sat.orbitPrimitive.show = isVisible && state.globalShowOrbits;
      }
      
      // 卫星点位可见性 = 自身可见
      sat.satelliteEntity.show = isVisible;
      // 标签可见性 = 自身可见 && 全局标签开启
      sat.satelliteEntity.label.show = isVisible && state.globalShowLabels;
    }

    /**
     * 5. 实时更新所有卫星位置和轨道
     * @param {Cesium.JulianDate} time - 当前时间
     */
    function updateSatellites(time) {
      //console.log("update: ",time);
      const date = Cesium.JulianDate.toDate(time);
      const gmst = satellite.gstime(date); // 计算格林尼治恒星时
      const rotationMatrix = Cesium.Matrix4.fromRotation(
        new Cesium.Matrix3.fromRotationZ(-gmst) // 地球自转矩阵
      );

      state.satellites.forEach(sat => {
        // 只更新可见卫星
        if (sat.isVisible) {
          // 更新轨道旋转
          if(viewer.scene.mode === Cesium.SceneMode.SCENE3D && sat.orbitPrimitive!==null){
            sat.orbitPrimitive.modelMatrix = rotationMatrix;
          }

          // 更新卫星位置（ECI -> ECF）
          const eciPos = satellite.propagate(sat.satrec, date).position;
        const isNumber = (val) => typeof val === 'number' && !isNaN(val) && isFinite(val);
        if(!(isNumber(eciPos.x)&&isNumber(eciPos.y)&&isNumber(eciPos.z))){
          console.log(sat.name,"propagate error");
          return;
        }

          const ecfPos = satellite.eciToEcf(eciPos, gmst);
          sat.satelliteEntity.position = new Cesium.Cartesian3(
            ecfPos.x * 1000,
            ecfPos.y * 1000,
            ecfPos.z * 1000
          );
        }
      });
    }
    /**
     * 初始化函数
     */
    async function init() {
      // 初始化拖动功能
      initDragFunctionality();
      // 加载TLE数据
      const tleList = await loadTLEFile("starlink.txt");//"starlink.txt");//"beidou.txt");
      if (tleList.length === 0) {
        console.error("未加载到有效TLE数据");
        return;
      }
      let t0 = viewer.clock.currentTime;
      let jdt0=Cesium.JulianDate.totalDays(t0);
      var tt = new Cesium.JulianDate();
      let t1 = Cesium.JulianDate.clone(t0,tt);
      //console.log(t0,jdt0,t0.dayNumber+t0.secondsOfDay/86400);
      // 创建所有卫星并统计成功创建的数量
      let validSatelliteCount = 0;
      tleList.forEach(tle => {
        const sat = createSatellite(tle);
        if (sat){
            state.satellites.push(sat);
            validSatelliteCount++; // 只统计成功创建的卫星
            jdt0 = Cesium.JulianDate.totalDays(t0);
            let dt = jdt0 - sat.satrec.jdsatepoch;
            //console.log(jdt0,sat.satrec.jdsatepoch,dt);
            tt = Cesium.JulianDate.clone(t0,tt);
            Cesium.JulianDate.addSeconds(tt,-dt*86400+sat.params.period*60,tt);
            //console.log("tt: ",tt);
            if(validSatelliteCount===1){
              Cesium.JulianDate.clone(tt,t1);
            }else{
              if(tt>t1){
                Cesium.JulianDate.clone(tt,t1);
              }
            }
            if(dt>0){
              Cesium.JulianDate.addSeconds(t0,-dt*86400,t0);
            }
        }
      });
      console.log("t0: ",t0,"t1: ",t1);
      console.log("total: ",validSatelliteCount);
    //satelliteListTitle.textContent = `卫星列表(${validSatelliteCount})`;
      // 关键：所有卫星加载完成后，对轨道面进行排序
      sortOrbitPlanes();

      // 全局开关事件
      toggleAllOrbits.addEventListener("change", (e) => {
        state.globalShowOrbits = e.target.checked;
        state.satellites.forEach(sat => updateSatelliteVisibility(sat));
      });

      toggleAllLabels.addEventListener("change", (e) => {
        state.globalShowLabels = e.target.checked;
        state.satellites.forEach(sat => updateSatelliteVisibility(sat));
      });
      let globeRotate = new GlobeRotate(viewer);
      toggleEarthRotate.addEventListener("change", (e) => {
        if( e.target.checked)
            globeRotate.start();
        else
            globeRotate.stop();
        state.satellites.forEach(sat => updateSatelliteVisibility(sat));
      });
      globeRotate.start();
      viewer.clock.startTime = t0;
      viewer.clock.stopTime = t1;
      viewer.clock.currentTime = t0;
      viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
      viewer.timeline.zoomTo(t0,t1);
      viewer.clock.shouldAnimate = false;
      updateSatellites(t0);
// 第二步：分批次创建轨道（初始化完成后开始）
  setTimeout(() => {
    createOrbitsInBatches(state.satellites, 30, 200); // 每批30个，间隔200ms
  }, 500); // 延迟500ms，确保点和UI先加载完成
  //updateSatellites(viewer.clock.currentTime);
  //       // 监听时间变化，实时更新
      viewer.clock.onTick.addEventListener(clock => {
        if(clock.shouldAnimate){
          updateSatellites(clock.currentTime);
        }
      });
// 监听时间线手动调整（暂停时拖动时间线也会触发）
viewer.timeline.addEventListener('settime', (event) => {
  // 从事件对象的clock属性中获取当前时间
  const currentTime = event.clock.currentTime;
  if (currentTime) {
    updateSatellites(currentTime);
  }
});
let currentMode = viewer.scene.mode;
viewer.scene.morphComplete.addEventListener(() => {
  // mode 表示切换后的视图模式：
  // - Cesium.SceneMode.SCENE2D：2D视图
  // - Cesium.SceneMode.SCENE3D：3D视图
  // - Cesium.SceneMode.COLUMBUS_VIEW：哥伦布视图
const newMode = viewer.scene.mode;
  console.log("视图模式切换完成，当前模式：", newMode,currentMode);
  if(newMode === Cesium.SceneMode.SCENE2D){//换到2D
    viewer.scene.camera.position.z=50000000;
    
  }//else if(newMode === Cesium.SceneMode.SCENE3D){//转换回3D
  if(currentMode === Cesium.SceneMode.SCENE3D || newMode === Cesium.SceneMode.SCENE3D){
    //updateOrbit(viewer.clock.currentTime);
    updateOrbitsInBatches(state.satellites,50,200);
  }
  //}
  
  currentMode = newMode;
});
      /*viewer.scene.preUpdate.addEventListener(() => {
        const newMode = viewer.scene.mode;
        if (newMode !== currentMode) {
          if(newMode === Cesium.SceneMode.SCENE2D){
            console.log("2D",viewer.scene.camera.position.z);
            viewer.scene.camera.position.z=50000000;
            //state.satellites.forEach(sat => {sat.orbitPrimitive.modelMatrix =Cesium.Matrix4.IDENTITY;});
            updateOrbit(viewer.clock.currentTime);
          }
          currentMode = newMode;
        }
      });*/
      // 初始视角
      /*if (state.satellites.length > 0) {
        viewer.zoomTo(state.satellites[0].satelliteEntity, new Cesium.HeadingPitchRange(0, -0.5, 10000000));
      }*/
    }

    // 启动应用
    init();
    //console.log(state);
  </script>
</body>
</html>
