<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>卫星轨道可视化系统</title>
  <link rel="stylesheet" href="https://unpkg.com/cesium@1.134/Build/Cesium/Widgets/widgets.css">
  <script src="https://unpkg.com/cesium@1.134/Build/Cesium/Cesium.js"></script>
  <script src="https://unpkg.com/satellite.js@5.0.0/dist/satellite.min.js"></script>
  <script src="./globeRotate.js"></script>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    #cesiumContainer {
      width: 100%;
      height: 100%;
    }
    .control-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 340px;
      max-height: 85vh;
      overflow-y: auto;
      background: rgba(30, 30, 30, 0.9);
      color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      font-family: 'Segoe UI', Arial, sans-serif;
      z-index: 1000;
      user-select: none;
    }
    .panel-header {
      padding: 12px 15px;
      border-bottom: 1px solid #444;
      cursor: move;
      background: rgba(40, 40, 40, 0.95);
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
    }
    .panel-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 500;
    }
    .panel-content {
      padding: 15px;
    }
    .global-controls {
      margin-bottom: 15px;
      padding: 0;
    }
    .control-item {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      width: 100%;
    }
    .toggle-switch {
      position: relative;
      width: 0px;
      height: 20px;
      margin: 0;
      appearance: none;
      cursor: pointer;
    }
    .toggle-switch + label {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
      background: #af4c4c;
      border: 0.5px solid rgba(117, 117, 117, 0.31);
      box-shadow: inset 0px 0px 2px 0px rgba(0,0,0,0.2);
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    .toggle-switch + label::before {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      box-shadow: inset 0.5px -1px 1px rgba(0, 0, 0, 0.35);
      background: #fff;
      transform: rotate(-20deg);
      left: 0;
      top: 0;
      border-radius: 50%;
      transition: transform 0.3s ease, left 0.3s ease;
    }
    .toggle-switch:checked + label {
      background: #4caf50;
    }
    .toggle-switch:checked + label::before {
      left: 20px;
      transform: rotate(20deg);
    }
    .switch-label-text {
      font-size: 12px;
      user-select: none;
      flex: 1;
    }
    /* 分组样式 */
    .constellation-group {
      border-top: 1px solid #444;
      padding-top: 15px;
      margin-top: 10px;
    }
    .constellation-header {
      margin: 10px 0 5px 0;
      padding: 6px 10px;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: rgba(60, 100, 180, 0.7);
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .level-1-group {
      margin-left: 15px;
      margin-bottom: 10px;
    }
    .level-1-header {
      margin: 8px 0 5px 0;
      padding: 5px 8px;
      font-size: 13px;
      font-weight: 500;
      color: #e0e0e0;
      background: rgba(80, 80, 120, 0.6);
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .level-2-group {
      margin-left: 30px;
      margin-bottom: 8px;
    }
    .level-2-header {
      margin: 6px 0 5px 0;
      padding: 4px 6px;
      font-size: 12px;
      font-weight: 500;
      color: #d0d0d0;
      background: rgba(80, 120, 80, 0.6);
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
      /* 三级分组（轨道面）- 修复类名和样式 */
  .level-3-group {
    margin-left: 45px; /* 三级分组缩进更大 */
    margin-bottom: 8px;
  }
  .level-3-header {
    margin: 6px 0 5px 0;
    padding: 4px 6px;
    font-size: 12px;
    font-weight: 500;
    color: #d0d0d0;
    background: rgba(120, 80, 80, 0.6); /* 三级分组颜色区分 */
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
    .group-content {
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .group-collapsed .group-content {
      max-height: 0;
    }
    /* 确保嵌套的分组能正确应用样式 */
.level-1-group.group-collapsed > .group-content,
.level-2-group.group-collapsed > .group-content,
.level-3-group.group-collapsed > .group-content {
  max-height: 0;
}
    .group-expanded .group-content {
      max-height: 18000px;
    }
    .group-toggle {
      font-size: 10px;
      transition: transform 0.2s ease;
      margin-right: 5px;
    }
    .group-collapsed .group-toggle {
      transform: rotate(-90deg);
    }
    .group-expanded .group-toggle {
      transform: rotate(0);
    }
    .group-count {
      font-size: 11px;
      color: #ccc;
      background: rgba(50, 50, 50, 0.7);
      padding: 0 5px;
      border-radius: 8px;
    }
    .group-control {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .satellite-item {
      display: flex;
      align-items: center;
      padding: 5px 8px;
      margin: 0 0 4px 45px;
      border-radius: 3px;
      background: rgba(60, 60, 60, 0.5);
      cursor: pointer;
      transition: background 0.2s;
      font-size: 12px;
    }
    .satellite-item:hover {
      background: rgba(80, 80, 80, 0.7);
    }
    .satellite-item .visibility-indicator {
      width: 12px;
      height: 12px;
      border: 1px solid #aaa;
      border-radius: 2px;
      margin-right: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .satellite-item.visible .visibility-indicator {
      background-color: #4CAF50;
      border-color: #4CAF50;
    }
    .satellite-item.visible .visibility-indicator::after {
      content: "✓";
      font-size: 9px;
      color: white;
    }
    .satellite-item .name {
      flex: 1;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  
  <!-- 可拖动的控制面板 -->
  <div class="control-panel" id="draggablePanel">
    <div class="panel-header" id="dragHandle">
      <h3>卫星轨道控制</h3>
    </div>
    <div class="panel-content">
      <div class="global-controls">
        <div class="control-item">
          <input type="checkbox" id="toggleEarthRotate" class="toggle-switch" checked>
          <label for="toggleEarthRotate"></label>
          <span class="switch-label-text">地球自转</span>
        </div>
        <div class="control-item">
          <input type="checkbox" id="toggleAllOrbits" class="toggle-switch" checked>
          <label for="toggleAllOrbits"></label>
          <span class="switch-label-text">显示所有轨道</span>
        </div>
        <div class="control-item">
          <input type="checkbox" id="toggleAllLabels" class="toggle-switch" checked>
          <label for="toggleAllLabels"></label>
          <span class="switch-label-text">显示所有卫星名称</span>
        </div>
      </div>
      
      <!-- 卫星分组容器 -->
      <div class="satellite-groups" id="satelliteGroupsContainer">
        <!-- 分组内容将通过JS动态生成 -->
      </div>
    </div>
  </div>

  <script>
    // 初始化Cesium地图
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI0NmM1M2YxNC01YWNmLTQzOTAtYmY4MC02YWVlNTE2NDM3ZDYiLCJpZCI6MjYxOTQzLCJpYXQiOjE3MzM5OTU2MjB9.5cQ0mYBL1o0OQVIbB4J0BjTAxc-NoOxwHgwpYtJP-K8';
    window.CESIUM_BASE_URL = "https://unpkg.com/cesium@1.134/Build/Cesium/";
    const viewer = new Cesium.Viewer("cesiumContainer", {
      animation: true,
      timeline: true,
      sceneModePicker: true,
      baseLayerPicker: true,
    });

    // 全局状态管理
    const state = {
      constellations: {}, // 存储星座及内部分组结构
      satellites: [],          // 存储所有卫星数据
      globalShowOrbits: true,  // 全局轨道显示状态
      globalShowLabels: true   // 全局名称显示状态
    };

    // DOM元素引用
    const satelliteGroupsContainer = document.getElementById("satelliteGroupsContainer");
    const toggleAllOrbits = document.getElementById("toggleAllOrbits");
    const toggleAllLabels = document.getElementById("toggleAllLabels");
    const toggleEarthRotate = document.getElementById("toggleEarthRotate");
    const draggablePanel = document.getElementById("draggablePanel");
    const dragHandle = document.getElementById("dragHandle");

    /**
     * 实现控制面板拖动功能
     */
    function initDragFunctionality() {
      let isDragging = false;
      let offsetX, offsetY;

      // 鼠标按下时记录初始位置
      dragHandle.addEventListener('mousedown', (e) => {
        isDragging = true;
        const panelRect = draggablePanel.getBoundingClientRect();
        offsetX = e.clientX - panelRect.left;
        offsetY = e.clientY - panelRect.top;
        dragHandle.style.cursor = 'grabbing'; // 显示抓取光标
        document.body.style.userSelect = 'none'; // 防止拖动时选中文本
      });

      // 鼠标移动时更新面板位置
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        // 计算新位置（限制在窗口内）
        const newX = e.clientX - offsetX;
        const newY = e.clientY - offsetY;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const panelWidth = draggablePanel.offsetWidth;
        const panelHeight = draggablePanel.offsetHeight;

        // 限制面板在窗口可视范围内
        const constrainedX = Math.max(0, Math.min(newX, windowWidth - panelWidth));
        const constrainedY = Math.max(0, Math.min(newY, windowHeight - panelHeight));

        // 更新位置
        draggablePanel.style.left = `${constrainedX}px`;
        draggablePanel.style.top = `${constrainedY}px`;
        draggablePanel.style.right = 'auto'; // 取消右侧定位
        draggablePanel.style.bottom = 'auto'; // 取消底部定位
      });

      // 鼠标释放时结束拖动
      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          dragHandle.style.cursor = 'move'; // 恢复移动光标
          document.body.style.userSelect = ''; // 恢复文本选择
        }
      });

      // 鼠标离开窗口时结束拖动
      document.addEventListener('mouseleave', () => {
        if (isDragging) {
          isDragging = false;
          dragHandle.style.cursor = 'move';
          document.body.style.userSelect = '';
        }
      });
    }
    /**
     * 确定卫星所属分组
     * 根据卫星名称特征进行分组
     */
    function getConstellation(satelliteName) {
      const name = satelliteName.toLowerCase();
      if (name.includes('gps')) return 'GPS卫星';
      if (name.includes('noaa')) return 'NOAA卫星';
      if (name.includes('starlink')) return 'Starlink卫星';
      if (name.includes('iss') || name.includes('zarya')) return '国际空间站';
      if (name.includes('hst') || name.includes('hubble')) return '哈勃望远镜';
      if (name.includes('cosmos')) return '格洛纳斯卫星';
      if (name.includes('galileo')) return '伽利略卫星';
      if (name.includes('qzss')) return '日本准天顶卫星';
      if (name.includes('irnss')) return '印度导航卫星';
      if (name.includes('beidou-2') || name.includes('compass')) return '北斗2卫星';
      if (name.includes('beidou-3 ') || name.includes('compass')) return '北斗3卫星';
      return '其他卫星'; // 未匹配到的卫星归入其他组
    }

    /**
     * 从TLE数据解析轨道参数
     */
    function getOrbitParameters(satrec) {
      // 轨道周期（分钟）
      //const period = satrec.no ? (1440 / (satrec.no * 24 / 1.02759)) : 0;
      const period = 2*Math.PI/satrec.no;
      
      // 轨道倾角（度）
      const inclination = satrec.inclo / Math.PI * 180;
      
      // 升交点赤经（度）
      const raan = satrec.nodeo / Math.PI * 180;
      
      return {
        period,
        inclination,
        raan,
        // 标准化RAAN（0-360度）
        normalizedRaan: ((raan % 360) + 360) % 360
      };
    }

    /**
     * 第二步：星座内一级分组（轨道类型）
     */
    function getConstellationLevel1(constellationId, params) {
      // 地球同步轨道周期约1436分钟（23小时56分）
      const isGeosynchronous = Math.abs(params.period - 1436) < 60;
      //console.log(params.period,params.period/60);
      if (isGeosynchronous) {
        if (params.inclination < 5) {
          return { id: 'geo', name: '地球静止轨道 (GEO)' };
        } else {
          return { id: 'igso', name: '倾斜地球同步轨道 (IGSO)' };
        }
      } else if (params.period < 100) { // <20小时
        return { id: 'leo', name: '低轨道 (LEO)' };
      } else if (params.period < 1200){
        return { id: 'meo', name: '中轨道 (MEO)'};
      } else{
        return { id: 'other', name: '其他轨道' };
      }
    }

    /**
     * 第三步：星座内二级分组（仅中低轨道需要）
     * 按轨道倾角（相差<1度归为一类）
     */
    function getConstellationLevel2(constellationId, level1Id, params, existingGroups) {
      // GEO/IGSO不细分二级分组
      if (level1Id === 'geo' || level1Id === 'igso') {
        return { id: 'none', name: '无需细分' };
      }
      //console.log("func getL2:",existingGroups);
      
      // 中低轨按倾角聚类（相差<1度）
      const targetIncl = params.inclination;
      for (const groupId in existingGroups) {
        const incl = parseFloat(groupId.replace('incl_', ''));
        if (Math.abs(incl - targetIncl) < 5) {
          return {
            id: groupId,
            name: `轨道倾角: ${incl.toFixed(0)}°`
          };
        }
      }
      
      // 创建新分组
      const inclStr = targetIncl.toFixed(0);
      return {
        id: `incl_${inclStr}`,
        name: `轨道倾角: ${inclStr}°`
      };
    }

    /**
     * 第四步：星座内三级分组（仅中低轨道需要）
     * 按升交点赤经RAAN（相差<1度归为一个轨道面）
     */
    function getConstellationLevel3(constellationId, level1Id, level2Id, params, existingGroups) {
      // GEO/IGSO不细分三级分组
      if (level1Id === 'geo' || level1Id === 'igso') {
        return { id: 'none', name: '无需细分' };
      }
      
      // 中低轨按RAAN聚类（相差<1度）
      const targetRaan = params.normalizedRaan;
      for (const groupId in existingGroups) {
        const raan = parseFloat(groupId.replace('raan_', ''));
        if (Math.abs(raan - targetRaan) < 10) {
          return {
            id: groupId,
            name: `轨道面 (RAAN: ${raan.toFixed(0)}°)`,
            raanValue: raan // 存储RAAN值用于排序
          };
        }
      }
      
      // 创建新分组
      const raanStr = targetRaan.toFixed(0);
      const raanValue = parseFloat(raanStr);
      return {
        id: `raan_${raanStr}`,
        name: `轨道面 (RAAN: ${raanStr}°)`,
        raanValue: raanValue // 存储RAAN值用于排序
      };
    }

    /**
     * 创建完整分组结构：星座 → 轨道类型 → 倾角 → 轨道面
     */
    function createGroupStructure(satellite) {
      const { constellation, level1, level2, level3, params } = satellite;
      //console.log(constellation,level1,level2);
      
      // 1. 初始化星座分组
      if (!state.constellations[constellation]) {
        const constelElement = document.createElement('div');
        constelElement.className = 'constellation-group group-expanded';
        const switchId = `constel_${constellation}`;
        
        constelElement.innerHTML = `
          <div class="constellation-header">
            <span class="group-toggle">▸</span>
            <span>${constellation}</span>
            <span class="group-count">0</span>
            <div class="group-control">
              <input type="checkbox" id="${switchId}" class="toggle-switch" checked>
              <label for="${switchId}"></label>
            </div>
          </div>
          <div class="group-content"></div>
        `;
        
        // 星座折叠/展开
        const header = constelElement.querySelector('.constellation-header');
        header.addEventListener('click', (e) => {
          if (!e.target.closest('.group-control')) {
            constelElement.classList.toggle('group-expanded');
            constelElement.classList.toggle('group-collapsed');
          }
        });
        
        // 星座显隐控制
        const toggle = constelElement.querySelector('.toggle-switch');
        toggle.addEventListener('change', (e) => {
          toggleConstellationSatellites(constellation, e.target.checked);
        });
        
        state.constellations[constellation] = {
          name: constellation,
          element: constelElement,
          countElement: constelElement.querySelector('.group-count'),
          toggleElement: toggle,
          level1Groups: {}
        };
        
        satelliteGroupsContainer.appendChild(constelElement);
      }
      
      const constellationGroup = state.constellations[constellation];
      
      // 2. 初始化星座内一级分组（轨道类型）
      if (!constellationGroup.level1Groups[level1.id]) {
        const level1Element = document.createElement('div');
        level1Element.className = 'level-1-group group-expanded';
        const switchId = `level1_${constellation}_${level1.id}`;
        
        level1Element.innerHTML = `
          <div class="level-1-header">
            <span class="group-toggle">▸</span>
            <span>${level1.name}</span>
            <span class="group-count">0</span>
            <div class="group-control">
              <input type="checkbox" id="${switchId}" class="toggle-switch" checked>
              <label for="${switchId}"></label>
            </div>
          </div>
          <div class="group-content"></div>
        `;
        
        // 一级分组折叠/展开
        const header = level1Element.querySelector('.level-1-header');
        header.addEventListener('click', (e) => {
          if (!e.target.closest('.group-control')) {
            level1Element.classList.toggle('group-expanded');
            level1Element.classList.toggle('group-collapsed');
          }
        });
        
        // 一级分组显隐控制
        const toggle = level1Element.querySelector('.toggle-switch');
        toggle.addEventListener('change', (e) => {
          toggleLevel1Satellites(constellation, level1.id, e.target.checked);
        });
        
        constellationGroup.level1Groups[level1.id] = {
          name: level1.name,
          id:level1.id,
          element: level1Element,
          countElement: level1Element.querySelector('.group-count'),
          toggleElement: toggle,
          level2Groups: {}
        };
        
        constellationGroup.element.querySelector('.group-content').appendChild(level1Element);
      }
      
      const level1Group = constellationGroup.level1Groups[level1.id];
      
      // GEO/IGSO不创建二级和三级分组
      if (level1.id === 'geo' || level1.id === 'igso') {
        // 将卫星直接添加到一级分组
        if (!level1Group.satellites) level1Group.satellites = [];
        level1Group.satellites.push(satellite.name);
        updateGroupCounts();
        return level1Group.element.querySelector('.group-content');
      }
      
      // 3. 初始化星座内二级分组（倾角）
      if (!level1Group.level2Groups[level2.id]) {
        const level2Element = document.createElement('div');
        level2Element.className = 'level-2-group group-expanded';
        const switchId = `level2_${constellation}_${level1.id}_${level2.id}`;
        
        level2Element.innerHTML = `
          <div class="level-2-header">
            <span class="group-toggle">▸</span>
            <span>${level2.name}</span>
            <span class="group-count">0</span>
            <div class="group-control">
              <input type="checkbox" id="${switchId}" class="toggle-switch" checked>
              <label for="${switchId}"></label>
            </div>
          </div>
          <div class="group-content"></div>
        `;
        
        // 二级分组折叠/展开
        const header = level2Element.querySelector('.level-2-header');
        header.addEventListener('click', (e) => {
          if (!e.target.closest('.group-control')) {
            level2Element.classList.toggle('group-expanded');
            level2Element.classList.toggle('group-collapsed');
          }
        });
        
        // 二级分组显隐控制
        const toggle = level2Element.querySelector('.toggle-switch');
        toggle.addEventListener('change', (e) => {
          toggleLevel2Satellites(constellation, level1.id, level2.id, e.target.checked);
        });
        
        level1Group.level2Groups[level2.id] = {
          name: level2.name,
          id: level2.id,
          element: level2Element,
          countElement: level2Element.querySelector('.group-count'),
          toggleElement: toggle,
          level3Groups: {}
        };
        
        level1Group.element.querySelector('.group-content').appendChild(level2Element);
      }
      
      const level2Group = level1Group.level2Groups[level2.id];
      
      // 4. 初始化星座内三级分组（轨道面）
      if (!level2Group.level3Groups[level3.id]) {
        const level3Element = document.createElement('div');
        level3Element.className = 'level-3-group group-expanded';
        const switchId = `level3_${constellation}_${level1.id}_${level2.id}_${level3.id}`;
        
        level3Element.innerHTML = `
          <div class="level-3-header">
            <span class="group-toggle">▸</span>
            <span>${level3.name}</span>
            <span class="group-count">0</span>
            <div class="group-control">
              <input type="checkbox" id="${switchId}" class="toggle-switch" checked>
              <label for="${switchId}"></label>
            </div>
          </div>
          <div class="group-content"></div>
        `;
        
        // 三级分组折叠/展开
        const header = level3Element.querySelector('.level-3-header');
        header.addEventListener('click', (e) => {
          if (!e.target.closest('.group-control')) {
            level3Element.classList.toggle('group-expanded');
            level3Element.classList.toggle('group-collapsed');
          }
        });
        
        // 三级分组显隐控制
        const toggle = level3Element.querySelector('.toggle-switch');
        toggle.addEventListener('change', (e) => {
          toggleLevel3Satellites(constellation, level1.id, level2.id, level3.id, e.target.checked);
        });
        
        level2Group.level3Groups[level3.id] = {
          name: level3.name,
          id: level3.id,
          element: level3Element,
          countElement: level3Element.querySelector('.group-count'),
          toggleElement: toggle,
          satellites: [],
          raanValue: level3.raanValue // 关键：保存RAAN值
        };
        
        level2Group.element.querySelector('.group-content').appendChild(level3Element);
      }
      
      // 将卫星添加到三级分组
      const level3Group = level2Group.level3Groups[level3.id];
      level3Group.satellites.push(satellite.name);
      
      // 更新各级计数
      updateGroupCounts();
      
      return level3Group.element.querySelector('.group-content');
    }
    /**
     * 新增：按RAAN值排序轨道面分组
     */
    function sortOrbitPlanes() {
      // 遍历所有星座
      Object.values(state.constellations).forEach(constellation => {
        // 遍历星座内的一级分组（仅处理中低轨道）
        Object.values(constellation.level1Groups).forEach(level1Group => {
          if (level1Group.id === 'geo' || level1Group.id === 'igso') return; // 只排序中低轨的轨道面
          
          // 遍历二级分组（倾角）
          Object.values(level1Group.level2Groups).forEach(level2Group => {
            const level3Container = level2Group.element.querySelector('.group-content');
            if (!level3Container) return;
            
            // 1. 获取当前二级分组下的所有轨道面分组，并按RAAN值排序
            const sortedLevel3Groups = Object.values(level2Group.level3Groups)
              .sort((a, b) => a.raanValue - b.raanValue); // 按RAAN从小到大排序
            
            // 2. 清空容器并按排序后的顺序重新添加轨道面
            level3Container.innerHTML = '';
            sortedLevel3Groups.forEach(level3Group => {
              level3Container.appendChild(level3Group.element);
            });
          });
        });
      });
    }
    /**
     * 更新所有分组的计数
     */
    function updateGroupCounts() {
      // 遍历所有星座
      Object.values(state.constellations).forEach(constellation => {
        let constelCount = 0;
        
        // 遍历星座内一级分组
        Object.values(constellation.level1Groups).forEach(level1 => {
          let level1Count = 0;
          // GEO/IGSO直接统计一级分组内的卫星
          if (level1.id === 'geo' || level1.id === 'igso') {
            level1Count = level1.satellites?.length || 0;
            level1.countElement.textContent = level1Count;
            constelCount += level1Count;
            return;
          }
          
          // 中低轨统计二级分组
          Object.values(level1.level2Groups).forEach(level2 => {
            let level2Count = 0;
            
            // 统计三级分组
            Object.values(level2.level3Groups).forEach(level3 => {
              const count = level3.satellites.length;
              level3.countElement.textContent = count;
              level2Count += count;
            });
            
            level2.countElement.textContent = level2Count;
            level1Count += level2Count;
          });
          
          level1.countElement.textContent = level1Count;
          constelCount += level1Count;
        });
        
        constellation.countElement.textContent = constelCount;
      });
    }

    /**
     * 切换整个星座的卫星显隐
     */
    function toggleConstellationSatellites(constellationId, isVisible) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      // 遍历星座内所有一级分组
      Object.values(constellation.level1Groups).forEach(level1 => {
        // GEO/IGSO直接处理一级分组内卫星
        if (level1.id === 'geo' || level1.id === 'igso') {
          level1.satellites?.forEach(satName => {
            updateSatelliteVisibilityByName(satName, isVisible);
          });
          level1.toggleElement.checked = isVisible;
          return;
        }
        
        // 处理中低轨的二级和三级分组
        Object.values(level1.level2Groups).forEach(level2 => {
          Object.values(level2.level3Groups).forEach(level3 => {
            level3.satellites.forEach(satName => {
              updateSatelliteVisibilityByName(satName, isVisible);
            });
            level3.toggleElement.checked = isVisible;
          });
          level2.toggleElement.checked = isVisible;
        });
        level1.toggleElement.checked = isVisible;
      });
    }

    /**
     * 切换星座内一级分组的卫星显隐
     */
    function toggleLevel1Satellites(constellationId, level1Id, isVisible) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      // GEO/IGSO直接处理一级分组内卫星
      if (level1.id === 'geo' || level1.id === 'igso') {
        level1.satellites?.forEach(satName => {
          updateSatelliteVisibilityByName(satName, isVisible);
        });
        level1.toggleElement.checked = isVisible;
        syncConstellationToggleState(constellationId);
        return;
      }
      
      // 处理中低轨的二级和三级分组
      Object.values(level1.level2Groups).forEach(level2 => {
        Object.values(level2.level3Groups).forEach(level3 => {
          level3.satellites.forEach(satName => {
            updateSatelliteVisibilityByName(satName, isVisible);
          });
          level3.toggleElement.checked = isVisible;
        });
        level2.toggleElement.checked = isVisible;
      });
      
      syncConstellationToggleState(constellationId);
    }

    /**
     * 切换星座内二级分组的卫星显隐
     */
    function toggleLevel2Satellites(constellationId, level1Id, level2Id, isVisible) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      
      const level2 = level1.level2Groups[level2Id];
      if (!level2) return;
      
      // 处理三级分组
      Object.values(level2.level3Groups).forEach(level3 => {
        level3.satellites.forEach(satName => {
          updateSatelliteVisibilityByName(satName, isVisible);
        });
        level3.toggleElement.checked = isVisible;
      });
      
      syncLevel1ToggleState(constellationId, level1Id);
      syncConstellationToggleState(constellationId);
    }

    /**
     * 切换星座内三级分组的卫星显隐
     */
    function toggleLevel3Satellites(constellationId, level1Id, level2Id, level3Id, isVisible) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      
      const level2 = level1.level2Groups[level2Id];
      if (!level2) return;
      
      const level3 = level2.level3Groups[level3Id];
      if (!level3) return;
      
      // 更新卫星状态
      level3.satellites.forEach(satName => {
        updateSatelliteVisibilityByName(satName, isVisible);
      });
      level3.toggleElement.checked = isVisible;
      
      syncLevel2ToggleState(constellationId, level1Id, level2Id);
      syncLevel1ToggleState(constellationId, level1Id);
      syncConstellationToggleState(constellationId);
    }

    /**
     * 按名称更新卫星可见性
     */
    function updateSatelliteVisibilityByName(satName, isVisible) {
      const satellite = state.satellites.find(s => s.name === satName);
      if (satellite) {
        satellite.isVisible = isVisible;
        satellite.listItem.classList.toggle('visible', isVisible);
        updateSatelliteVisibility(satellite);
      }
    }

    /**
     * 同步二级分组开关状态
     */
    function syncLevel2ToggleState(constellationId, level1Id, level2Id) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      
      const level2 = level1.level2Groups[level2Id];
      if (!level2) return;
      
      const level3Groups = Object.values(level2.level3Groups);
      const allChecked = level3Groups.every(g => g.toggleElement.checked);
      const allUnchecked = level3Groups.every(g => !g.toggleElement.checked);
      
      if (allChecked) level2.toggleElement.checked = true;
      else if (allUnchecked) level2.toggleElement.checked = false;
    }

    /**
     * 同步一级分组开关状态
     */
    function syncLevel1ToggleState(constellationId, level1Id) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      
      // GEO/IGSO处理方式
      if (level1.id === 'geo' || level1.id === 'igso') {
        const allVisible = level1.satellites?.every(satName => {
          const sat = state.satellites.find(s => s.name === satName);
          return sat?.isVisible;
        }) || false;
        
        const allHidden = level1.satellites?.every(satName => {
          const sat = state.satellites.find(s => s.name === satName);
          return !sat?.isVisible;
        }) || false;
        
        if (allVisible) level1.toggleElement.checked = true;
        else if (allHidden) level1.toggleElement.checked = false;
        return;
      }
      
      // 中低轨处理方式
      const level2Groups = Object.values(level1.level2Groups);
      const allChecked = level2Groups.every(g => g.toggleElement.checked);
      const allUnchecked = level2Groups.every(g => !g.toggleElement.checked);
      
      if (allChecked) level1.toggleElement.checked = true;
      else if (allUnchecked) level1.toggleElement.checked = false;
    }

    /**
     * 同步星座开关状态
     */
    function syncConstellationToggleState(constellationId) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1Groups = Object.values(constellation.level1Groups);
      const allChecked = level1Groups.every(g => g.toggleElement.checked);
      const allUnchecked = level1Groups.every(g => !g.toggleElement.checked);
      
      if (allChecked) constellation.toggleElement.checked = true;
      else if (allUnchecked) constellation.toggleElement.checked = false;
    }

    /**
     * 1. 加载并解析TLE数据
     */
    async function loadTLEFile(filePath) {
      try {
        const response = await fetch(filePath);
        const text = await response.text();
        return parseTLE(text); // 解析TLE文本
      } catch (error) {
        console.error("读取TLE文件失败：", error);
        return [];
      }
    }

    // 2. 解析TLE文本
    function parseTLE(text) {
      const tleList = [];
      const lines = text.split(/[\n,]+/).map(line => line.trim()).filter(line => line);
      for (let i = 0; i + 2 < lines.length; i += 3) {
        const name = lines[i];
        const line1 = lines[i + 1];
        const line2 = lines[i + 2];
        if (line1.startsWith('1 ') && line2.startsWith('2 ')) {
          tleList.push({ name, line1, line2 });
        }
      }
      return tleList;
    }

    /**
     * 2. 预计算卫星轨道（ECI坐标系）
     * @param {Object} satrec - 卫星轨道参数
     * @param {number} points - 轨道点数量
     * @param {number} period - 轨道周期（毫秒）
     * @returns {Cesium.Cartesian3[]} 轨道点数组
     */
    function precomputeOrbit(satrec) {
      //console.log(satrec.ecco);
      const points = satrec.ecco>0.1?500:5;
      const period =  2*Math.PI/satrec.no*60*1000;
      const orbitPoints = [];
      const startTime = new Date();
      
      for (let i = 0; i < points; i++) {
        const time = new Date(startTime.getTime() + (i / points) * period);
        const position = satellite.propagate(satrec, time).position;
        
        // 转换为米并存储
        orbitPoints.push(Cesium.Cartesian3.fromElements(
          position.x * 1000,
          position.y * 1000,
          position.z * 1000
        ));
      }
      orbitPoints.push(orbitPoints[0]);
      return orbitPoints;
    }

    /**
     * 3. 创建卫星实体和轨道
     * @param {Object} tle - TLE数据
     */
    function createSatellite(tle) {
      try {
        // 解析TLE数据
        const satrec = satellite.twoline2satrec(tle.line1, tle.line2);
        if (satrec.error) throw new Error(satrec.error);

        // 1. 确定星座
        const constellation = getConstellation(tle.name);
        
        // 2. 获取轨道参数
        const params = getOrbitParameters(satrec);
        
        // 3. 确定星座内一级分组（轨道类型）
        const level1 = getConstellationLevel1(constellation, params);

        // 4. 确定星座内二级分组（倾角）
        const existingLevel2Groups = state.constellations[constellation]?.level1Groups[level1.id]?.level2Groups || {};
        const level2 = getConstellationLevel2(constellation, level1.id, params, existingLevel2Groups);
        
        // 5. 确定星座内三级分组（轨道面）
        const existingLevel3Groups = state.constellations[constellation]?.level1Groups[level1.id]?.level2Groups[level2.id]?.level3Groups || {};
        const level3 = getConstellationLevel3(constellation, level1.id, level2.id, params, existingLevel3Groups);

        // 预计算轨道
        const eciOrbit = precomputeOrbit(satrec);
        
        // 生成随机颜色（区分不同卫星）
        const color = Cesium.Color.fromRandom({
          minimumRed: 0.5,
          minimumGreen: 0.5,
          minimumBlue: 0.5,
          alpha: 0.8
        });

        // 创建轨道Primitive
        const orbitGeometry = new Cesium.PolylineGeometry({
          positions: eciOrbit,
          width: 1,
          vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT
        });
        const orbitInstance = new Cesium.GeometryInstance({
          geometry: orbitGeometry,
          id: tle.name
        });
        const orbitAppearance = new Cesium.PolylineMaterialAppearance({
          material: Cesium.Material.fromType(Cesium.Material.ColorType, { color })
        });
        const orbitPrimitive = new Cesium.Primitive({
          geometryInstances: orbitInstance,
          appearance: orbitAppearance,
          modelMatrix: Cesium.Matrix4.IDENTITY,
          show: true
        });
        viewer.scene.primitives.add(orbitPrimitive);

        // 创建卫星点实体
        const satelliteEntity = viewer.entities.add({
          name: tle.name,
          position: Cesium.Cartesian3.ZERO,
          point: {
            pixelSize: 6,
            color: color,
            outlineWidth: 1,
            outlineColor: Cesium.Color.BLACK
          },
          label: {
            text: tle.name,
            font: "12px sans-serif",
            pixelOffset: new Cesium.Cartesian2(0, 15),
            show: true
          },
          show: true
        });

        // 创建列表项
        const listItem = document.createElement("div");
        listItem.className = "satellite-item visible";
        listItem.innerHTML = `
          <span class="visibility-indicator"></span>
          <span class="name">${tle.name} (周期: ${params.period.toFixed(1)}分钟)</span>
        `;
        listItem.dataset.name = tle.name;

        // 卫星项点击事件
        listItem.addEventListener("click", (e) => {
          e.stopPropagation();
          const isVisible = !listItem.classList.contains("visible");
          listItem.classList.toggle("visible", isVisible);
          
          const satellite = state.satellites.find(s => s.name === tle.name);
          if (satellite) {
            satellite.isVisible = isVisible;
            updateSatelliteVisibility(satellite);
            
            // 同步各级开关状态
            if (level1.id === 'geo' || level1.id === 'igso') {
              syncLevel1ToggleState(constellation, level1.id);
            } else {
              syncLevel3ToggleState(constellation, level1.id, level2.id, level3.id);
              syncLevel2ToggleState(constellation, level1.id, level2.id);
              syncLevel1ToggleState(constellation, level1.id);
            }
            syncConstellationToggleState(constellation);
          }
        });

        // 将卫星添加到分组结构
        const parentContainer = createGroupStructure({
          name: tle.name,
          constellation,
          level1,
          level2,
          level3,
          params
        });
        parentContainer.appendChild(listItem);

        return {
          name: tle.name,
          constellation,
          level1,
          level2,
          level3,
          params,
          satrec,
          eciOrbit,
          orbitPrimitive,
          satelliteEntity,
          listItem,
          isVisible: true,
          color
        };
      } catch (error) {
        console.error(`创建卫星${tle.name}失败:`, error);
        return null;
      }
    }

    /**
     * 同步三级分组开关状态
     */
    function syncLevel3ToggleState(constellationId, level1Id, level2Id, level3Id) {
      const constellation = state.constellations[constellationId];
      if (!constellation) return;
      
      const level1 = constellation.level1Groups[level1Id];
      if (!level1) return;
      
      const level2 = level1.level2Groups[level2Id];
      if (!level2) return;
      
      const level3 = level2.level3Groups[level3Id];
      if (!level3) return;
      
      // 检查该组所有卫星状态
      const allVisible = level3.satellites.every(satName => {
        const sat = state.satellites.find(s => s.name === satName);
        return sat?.isVisible;
      });
      
      const allHidden = level3.satellites.every(satName => {
        const sat = state.satellites.find(s => s.name === satName);
        return !sat?.isVisible;
      });
      
      if (allVisible) level3.toggleElement.checked = true;
      else if (allHidden) level3.toggleElement.checked = false;
    }

    /**
     * 4. 更新卫星可见性（结合全局开关和自身状态）
     * @param {Object} sat - 卫星对象
     */
    function updateSatelliteVisibility(sat) {
      const { isVisible } = sat;
      // 轨道可见性 = 自身可见 && 全局轨道开启
      sat.orbitPrimitive.show = isVisible && state.globalShowOrbits;
      // 卫星点位可见性 = 自身可见
      sat.satelliteEntity.show = isVisible;
      // 标签可见性 = 自身可见 && 全局标签开启
      sat.satelliteEntity.label.show = isVisible && state.globalShowLabels;
    }

    /**
     * 5. 实时更新所有卫星位置和轨道
     * @param {Cesium.JulianDate} time - 当前时间
     */
    function updateSatellites(time) {
      const date = Cesium.JulianDate.toDate(time);
      const gmst = satellite.gstime(date); // 计算格林尼治恒星时
      const rotationMatrix = Cesium.Matrix4.fromRotation(
        new Cesium.Matrix3.fromRotationZ(-gmst) // 地球自转矩阵
      );

      state.satellites.forEach(sat => {
        // 只更新可见卫星
        if (sat.isVisible) {
          // 更新轨道旋转
          sat.orbitPrimitive.modelMatrix = rotationMatrix;

          // 更新卫星位置（ECI -> ECF）
          const eciPos = satellite.propagate(sat.satrec, date).position;
          const ecfPos = satellite.eciToEcf(eciPos, gmst);
          sat.satelliteEntity.position = new Cesium.Cartesian3(
            ecfPos.x * 1000,
            ecfPos.y * 1000,
            ecfPos.z * 1000
          );
        }
      });
    }

    /**
     * 初始化函数
     */
    async function init() {
      // 初始化拖动功能
      initDragFunctionality();
      // 加载TLE数据
      const tleList = await loadTLEFile("gnss.txt");//"starlink.txt");//"beidou.txt");
      if (tleList.length === 0) {
        console.error("未加载到有效TLE数据");
        return;
      }

      // 创建所有卫星并统计成功创建的数量
      let validSatelliteCount = 0;
      tleList.forEach(tle => {
        const sat = createSatellite(tle);
        if (sat){
            state.satellites.push(sat);
            validSatelliteCount++; // 只统计成功创建的卫星
        }
      });
      console.log("total: ",validSatelliteCount);
    //satelliteListTitle.textContent = `卫星列表(${validSatelliteCount})`;
      // 关键：所有卫星加载完成后，对轨道面进行排序
      sortOrbitPlanes();

      // 全局开关事件
      toggleAllOrbits.addEventListener("change", (e) => {
        state.globalShowOrbits = e.target.checked;
        state.satellites.forEach(sat => updateSatelliteVisibility(sat));
      });

      toggleAllLabels.addEventListener("change", (e) => {
        state.globalShowLabels = e.target.checked;
        state.satellites.forEach(sat => updateSatelliteVisibility(sat));
      });
      let globeRotate = new GlobeRotate(viewer);
      toggleEarthRotate.addEventListener("change", (e) => {
        if( e.target.checked)
            globeRotate.start();
        else
            globeRotate.stop();
        state.satellites.forEach(sat => updateSatelliteVisibility(sat));
      });
      globeRotate.start();
      // 监听时间变化，实时更新
      viewer.clock.onTick.addEventListener(clock => {
        updateSatellites(clock.currentTime);
      });

      // 初始视角
      /*if (state.satellites.length > 0) {
        viewer.zoomTo(state.satellites[0].satelliteEntity, new Cesium.HeadingPitchRange(0, -0.5, 10000000));
      }*/
    }

    // 启动应用
    init();
    //console.log(state);
  </script>
</body>
</html>
